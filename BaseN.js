// From [45678](https://github.com/45678/Base58)
// Modified by Dr I·T Generated by CoffeeScript 1.8.0

// TODO to continue ...

// example :
// f01701220d4ca21fd67b197375c10392f392adc4cd33fbce4575d435e23a664f0cbac60f7
// -> b32: bAFYBEIGUZIQ72Z5RS43VYEBZF44SVXCM2M73ZZCXLVBV4I5GMTYMXLDA64
//    b36: k2jmtxwo1dqtk9lf6xucp3tww0glq2whf7wb0djxjlu0mhdn01ni0d87
//    b58: zdj7WjkYH6EAciTGrsF2z5APTxtR6jytrCpcadLA81E3kYL6a
//    b64: mAXASINTKIf1nsZc3XBA5Lzkq3EzTP7zkV11DXiOmZPDLrGD3
//    qm: QmcfHufAK9ErQ9ZKJF7YX68KntYYBJngkGDoVKcZEJyRve

(function() {
  var BaseN, i;

  BaseN = (typeof module !== "undefined" && module !== null ? module.exports : void 0) || (window.BaseN = {});


  var BASES = {
   radix11: '0123456789-',
   radix12: '0123456789XE',
   hex: '0123456789ABCDEF',
   base16: '0123456789abcdef',
   radix16: '0123456789ABCDEF',
   radix26: 'ABCDEFGHiJKLMNoPQRSTUVWXYZ',

   base32t: '0123456789ABCDEFGHiJKLMNoPQRSTUV', // Triacontakaidecimal // 09AV
   base32c: '0123456789'+'ABCDEFGH.JK.MN.PQRST.VWXYZ'.replace(/\./g,''), // Crockfordś ![ILOU] (U:accidental obscenity)
   radix32: '123456789'+'abcdefgh.jk.mn.pqrstuvwxyz'.replace(/\./g,''),  // ![ilo0]
   base32z: 'ybndrfg8ejkmcpqxotluwisza345h769', // z-base32 ![01v2]
   RFC4648: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'+'.234567..'.replace(/\./g,''), // RFC 3548 / 4648

   radix36: 'ABCDEFGHiJKLMNoPQRSTUVWXYZ0123456789',
   base36: '0123456789'+'ABCDEFGHiJKLMNoPQRSTUVWXYZ',
   radix38: '0123456789ABCDEFGHiJKLMNoPQRSTUVWXYZ.-',
   radix40: 'ABCDEFGHiJKLMNoPQRSTUVWXYZ0123456789-_.+',
   radix43: 'ABCDEFGHiJKLMNoPQRSTUVWXYZ0123456789 -+.$%*',
   base58: '.123456789ABCDEFGH.JKLMN.PQRSTUVWXYZabcdefghijk.mnopqrstuvwxyz'.replace(/\./g,''), // ![0IOl]
   base62: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',
   base63: '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',
   base64m: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=', // RFC 2045
   base64u: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=', // Base64 URL
   uudencode: '!"#$%&'+"'"+'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_', 
   binhex4: '!"#$%&'+"'"+'()*+,-012345689@ABCDEFGHIJKLMNPQRSTUVXYZ[`abcdefhijklmpqr', // HQX 
   B64: './0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',
   bash64: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@_',
   base85: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'+'!#$%&()*+-;<=>?@^_`{|}~',
   radix94: '-0123456789'+ 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'+
                           'abcdefghijklmnopqrstuvwxyz'+
            "+.@$%_,~`'=;!^[]{}()#&" + '<>:"/\\|?*'
   } 
   var aliases = {
    'ilo0': '11zz',
    '01v2': 'olwz',
    '0189': 'OIBq'
   }
   console.log(BASES);
   BaseN.BASES = BASES;

  BaseN.maxN = BASES.radix94.length;

 var RX = {};
 for (base of Object.keys(BASES)) {
   let rx = BASES[base].length;
   RX[rx] = base;
 }
 console.log('RX:',RX);

 function alphabet(b) {
    let abet;
    if (b in BASES) {
       abet = BASES[b]
    } else if (`${b}` in RX) {
       abet = BASES[RX[b]]
       console.log('alphabet.b: %s, -e RX[b] = %s',b,RX[b])
    } else {
      for (let base of Object.keys(BASES)) {
           if (b < BASES[base].length) { abet = BASES[base]; break; }
      }
    }
    //console.log('alphabet.abet:',abet)
    return abet;
 }
 function alphamap(b) {
   let amap = {};
   for (i = 0; i < alphabet(b).length; i++) {
    amap[alphabet(b).charAt(i)] = i
   }
   return amap
 }

  BaseN.encode = function(buffer,base) {
    let v = 0;
    var carry, digits, j;
    if (buffer.length === 0) {
      return "";
    }
    var alphab = alphabet(base)
    console.log('encode.alphab[%s]: %s (#%s)',base,alphabet(base),alphabet(base).length);
    var N = alphab.length;
    digits = [0];
    for (i = 0; i < buffer.length ; i++) {
      for(j = 0; j < digits.length ; j++) {
        digits[j] <<= 8; // * 256
      }
      if (v) { console.log('* 256;  digits: [%s]',digits.join(',')) }
      digits[0] += buffer[i];
      if (v) { console.log('+ %s;  digits: [%s]',buffer[i],digits.join(',')) }
      carry = 0;
      for (j = 0; j < digits.length; j++) {
        digits[j] += carry;
        carry = (digits[j] / N) | 0; // bitwise or : make sure it is an integer
        digits[j] %= N;
      }
      if (v) { console.log('carry = x%s (%s)',carry.toString(16),carry) }
      while (carry) {
        digits.push(carry % N);
        carry = (carry / N) | 0;
      }
    }
    i = 0;
    /* wrong ! ... */
    while (buffer[i] === 0 && i < buffer.length - 1) {
      digits.push(0);
      i++;
    }
    return digits.reverse().map(function(digit) {
      return alphab[digit];
    }).join("");
  };

function a2s(buf,s) { /* Uint8Array to Hex */
  return Array.prototype.map.call(buf, x => 'x' + x.toString(16)).reverse().join(s);
}

  BaseN.decode = function(string, base) {
    let v = 0;
    var bytes, c, carry, j;
    if (string.length === 0) {
      return new (typeof Uint8Array !== "undefined" && Uint8Array !== null ? Uint8Array : Buffer)(0);
    }
    console.log('decode.alphab[%s]: %s (#%s)',base,alphabet(base),alphabet(base).length);
    var ab = alphabet(base);
    var zero = ab[0]; // TODO : optimized alphabet+alphamap
    var one = ab.slice(-1);
    console.log('zero: %s, one: %s',zero,one);
    var map = alphamap(base);
    console.log('decode.map:',map);
    var N = Object.keys(map).length;
    console.log('N:',N)
    bytes = [0];
    weights = [0];

    for (i = 0;i < string.length; i++) {
       c = string[string.length -1 - i]; // consume string from the end
       c = string[i];
       if (!(c in map)) {
          throw "BaseN.decode received unacceptable input. Character '" + c + "' is not in the BaseN alphabet :"+ alphabet(base);
       }

       // shift left bytes
       if (v) { console.log("i:%s; bytes: [%s] c:%s m[%s]=d'%s=x%s",i,a2s(bytes,','),c,c,map[c],map[c].toString(16)) }
       for (j = 0; j < bytes.length; j++) {
          bytes[j] *= N;
          weights[j] *= N;
       }
       if (v) { console.log('* N=%s;  bytes: [%s]',N,a2s(bytes,',')) }
       bytes[0] += map[c]; // add current chars' value
       if (v) { console.log('+ map[c];  bytes: [%s] c:%s map[%s]=x%s',a2s(bytes,','),c,c,map[c].toString(16)) }

       weights[0] += N-1;
       let pos = 0; // compute weight ...
       carry = 0; // compute carry ...
       for (j = 0; j < bytes.length; j++) {
          weights[j] += pos;
          pos = weights[j] >> 8;
          weights[j] &= 0xff;

          bytes[j] += carry;
          carry = bytes[j] >> 8;
          bytes[j] &= 0xff;
       }
       if (v) { console.log('        ;  weights: [%s]',a2s(weights,',')) }
       if (v) { console.log('carry = 0x%s (%s)',carry.toString(16),carry) }
       while (pos) { // propagate carry
          if (carry) {
             bytes.push(carry & 0xff);
             carry >>= 8;
             if (v) { console.log(' reminder: carry: 0x%s',carry.toString(16)) }
          } else {
            bytes.push(0);
          }
          weights.push(pos & 0xff);
          pos >>= 8;
          if (v) { console.log(' push: bytes: [%s]',a2s(bytes,',')) }
          if (v) { console.log('     weights: [%s]',a2s(weights,'.')) }
       }

    }
    console.log('bytes: [%s]',a2s(bytes,','));
    /*
          for(i = 0; string[i] === zero && i < string.length - 1; i++) {
          console.log('adding some zeros ... string[%s]=%s',i,string[i])
          bytes.push(0);
          }
        */
    return new (typeof Uint8Array !== "undefined" && Uint8Array !== null ? Uint8Array : Buffer)(bytes.reverse());
  };

}).call(this);
